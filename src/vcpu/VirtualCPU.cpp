//
// Created by gnilk on 14.12.23.
//
/*
    Suggested memory layout:
    address:
        0x0000 - 0x1000, CPU stuff
        0x0000 - 0x0100, 32 Interrupt Vectors, generated by the CPU
            {
                0   - initial stack pointer   -> default: MAX_RAM
                1   - initial program counter -> default: 0x2000
                2   - illegal instruction
                3   - hard fault
                4   - div.zero
                5   - debug/trace trap
                6   - mmu fault
                7   - fpu fault
                8   - Ext.HW L1 Interrupt, multiplexed
                9   - Ext.HW L2 Interrupt, multiplexed
                10  - Ext.HW L3 Interrupt, multiplexed
                11  - Ext.HW L4 Interrupt, multiplexed
                12  - Ext.HW L5 Interrupt, multiplexed
                13  - Ext.HW L6 Interrupt, multiplexed
                14  - Ext.HW L7 Interrupt, multiplexed
                15  - Ext.HW L8 Interrupt, multiplexed
                16..32 - Reserved
            }
        0x0100 - 0x1000,
*/

// FIX-THIS:
// 1) Make a pipeline with instr. decoding
// 2) Pipeline should have a queue of instructions, each instr. have a decoder, the decoder is state-based
// 3) rename 'step' to 'tick' - it should update the pipeline
// 4) once an instruction is read into the pipeline the size should be computed and the PipeLine IP moved to this address
// 5) Pipeline must have it's own address-ptr, so much each instr. decoder
//
// Once that is done - impl. some kind of Level1 cache handling and make the pipeline size configurable.
//


#include <stdlib.h>
#include <functional>
#include "fmt/format.h"
#include <limits>
#include "VirtualCPU.h"

#include "InstructionDecoder.h"
#include "InstructionSet.h"

using namespace gnilk;
using namespace gnilk::vcpu;




void VirtualCPU::QuickStart(void *ptrRam, size_t sizeOfRam) {
    CPUBase::QuickStart(ptrRam, sizeOfRam);
    AddPeripheral(CPUIntMask::INT0, CPUKnownIntIds::kTimer0, Timer::Create(1));
}

void VirtualCPU::Begin(void *ptrRam, size_t sizeOfRam) {
    CPUBase::Begin(ptrRam, sizeOfRam);
    AddPeripheral(CPUIntMask::INT0, CPUKnownIntIds::kTimer0, Timer::Create(1000));
}


void VirtualCPU::Reset() {
    CPUBase::Reset();
}

// Use this for debugging and similar..
bool VirtualCPU::Step() {


    // 1) update peripherals
    UpdatePeripherals();

    // 2) Invoke any Interrupt as a result..
    //    Note: Can't invoke interrupt if already inside one..
    InvokeISRHandlers();

    lastDecodedInstruction.cpuRegistersBefore = registers;
    lastDecodedInstruction.instrDecoder = {};
    lastDecodedInstruction.isrStateBefore = isrControlBlock.isrState;

    // if CPU is halted and we idle/waiting for ISR, don't decode and skip..
    if ((registers.statusReg.flags.halt == 1) && (isrControlBlock.isrState == CPUISRState::Waiting)) {
        // FIXME: A lot of things are 'wrong' here - esp. when we dump 'lastDecodedInstr'..
        return true;
    }

    InstructionDecoder instrDecoder;
    instrDecoder.Begin(GetInstrPtr().data.longword);

    instrDecoder.Decode(*this);

    // Advance forward..
    AdvanceInstrPtr(instrDecoder.GetInstrSizeInBytes());

    //
    // This would be cool:
    // Also, we should put enough information in the first 2-3 bytes to understand the fully decoded size
    // This way we can basically have multiple threads decoding instructions -> super scalar emulation
    //
    if (!ExecuteInstruction(instrDecoder)) {
        return false;
    }

    UpdateMMU();
    lastDecodedInstruction.isrStateAfter = isrControlBlock.isrState;
    lastDecodedInstruction.cpuRegistersAfter = registers;
    lastDecodedInstruction.instrDecoder = instrDecoder;
    return true;
}


