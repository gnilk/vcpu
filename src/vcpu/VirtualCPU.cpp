//
// Created by gnilk on 14.12.23.
//

/*
 * This defines a single step single execution CPU implementation.
 * One instruction is fetched, decoded and executed everytime we call 'Step'.
 *
 * See 'SuperScalarCPU' for an in-order pipeline implementation - which does parallel work in tick's rather..
 */



/*
    Suggested memory layout:
    address:
        0x0000 - 0x1000, CPU stuff
        0x0000 - 0x0100, 32 Interrupt Vectors, generated by the CPU
            {
                0   - initial stack pointer   -> default: MAX_RAM
                1   - initial program counter -> default: 0x2000
                2   - illegal instruction
                3   - hard fault
                4   - div.zero
                5   - debug/trace trap
                6   - mmu fault
                7   - fpu fault
                8   - Ext.HW L1 Interrupt, multiplexed
                9   - Ext.HW L2 Interrupt, multiplexed
                10  - Ext.HW L3 Interrupt, multiplexed
                11  - Ext.HW L4 Interrupt, multiplexed
                12  - Ext.HW L5 Interrupt, multiplexed
                13  - Ext.HW L6 Interrupt, multiplexed
                14  - Ext.HW L7 Interrupt, multiplexed
                15  - Ext.HW L8 Interrupt, multiplexed
                16..32 - Reserved
            }
        0x0100 - 0x1000,
*/


#include <stdlib.h>
#include <functional>
#include "fmt/format.h"
#include <limits>
#include "VirtualCPU.h"

#include "InstructionDecoder.h"
#include "InstructionSet.h"

using namespace gnilk;
using namespace gnilk::vcpu;

void VirtualCPU::QuickStart(void *ptrRam, size_t sizeOfRam) {
    CPUBase::QuickStart(ptrRam, sizeOfRam);
    AddPeripheral(CPUIntMask::INT0, CPUKnownIntIds::kTimer0, Timer::Create(1));
}

void VirtualCPU::Begin(void *ptrRam, size_t sizeOfRam) {
    CPUBase::Begin(ptrRam, sizeOfRam);
    AddPeripheral(CPUIntMask::INT0, CPUKnownIntIds::kTimer0, Timer::Create(1000));
}


void VirtualCPU::Reset() {
    CPUBase::Reset();
}

// Use this for debugging and similar..
bool VirtualCPU::Step() {

    // FIXME: Need to check if ISR's are enabled


    // 1) update peripherals
    UpdatePeripherals();

    // 2) Invoke any Interrupt as a result..
    //    Note: Can't invoke interrupt if already inside one..
    InvokeISRHandlers();

    lastDecodedInstruction.cpuRegistersBefore = registers;
    lastDecodedInstruction.instrDecoder = {};
    if (GetActiveISRControlBlock() != nullptr) {
        lastDecodedInstruction.isrStateBefore = GetActiveISRControlBlock()->isrState;
    }

    // if CPU is halted and we idle/waiting for ISR, don't decode and skip..
    if ((registers.statusReg.flags.halt == 1) && (GetActiveISRControlBlock() != nullptr)) {
        // FIXME: A lot of things are 'wrong' here - esp. when we dump 'lastDecodedInstr'..
        return true;
    }

    InstructionDecoder instrDecoder;
    instrDecoder.Decode(*this);

    // Note: The instruction decoder will advance the IP
    InstructionSetImpl instructionBase(*this);
    if (!instructionBase.ExecuteInstruction(instrDecoder)) {
        return false;
    }

    UpdateMMU();
    if (GetActiveISRControlBlock() != nullptr) {
        lastDecodedInstruction.isrStateAfter = GetActiveISRControlBlock()->isrState;
    }
    lastDecodedInstruction.cpuRegistersAfter = registers;
    lastDecodedInstruction.instrDecoder = instrDecoder;
    return true;
}


