//
// Created by gnilk on 14.12.23.
//

/*
 * This defines a single step single execution CPU implementation.
 * One instruction is fetched, decoded and executed everytime we call 'Step'.
 *
 * See 'SuperScalarCPU' for an in-order pipeline implementation - which does parallel work in tick's rather..
 */



/*
    Suggested memory layout:
    address:
        0x0000 - 0x1000, CPU stuff
        0x0000 - 0x0100, 32 Interrupt Vectors, generated by the CPU
            {
                0   - initial stack pointer   -> default: MAX_RAM
                1   - initial program counter -> default: 0x2000
                2   - illegal instruction
                3   - hard fault
                4   - div.zero
                5   - debug/trace trap
                6   - mmu fault
                7   - fpu fault
                8   - Ext.HW L1 Interrupt, multiplexed
                9   - Ext.HW L2 Interrupt, multiplexed
                10  - Ext.HW L3 Interrupt, multiplexed
                11  - Ext.HW L4 Interrupt, multiplexed
                12  - Ext.HW L5 Interrupt, multiplexed
                13  - Ext.HW L6 Interrupt, multiplexed
                14  - Ext.HW L7 Interrupt, multiplexed
                15  - Ext.HW L8 Interrupt, multiplexed
                16..32 - Reserved
            }
        0x0100 - 0x1000,
*/


#include <stdlib.h>
#include <functional>
#include "fmt/format.h"
#include <limits>
#include "VirtualCPU.h"

#include "InstructionSetV1/InstructionSetV1Decoder.h"
#include "InstructionSetV1/InstructionSetV1Def.h"

#include "InstructionSet.h"
#include "InstructionSetV1/InstructionSetV1.h"



using namespace gnilk;
using namespace gnilk::vcpu;

void VirtualCPU::QuickStart(void *ptrRam, size_t sizeOfRam) {
    CPUBase::QuickStart(ptrRam, sizeOfRam);

    // In quick-start mode we create a 'fake' timer - there is no mapping to anything in RAM...
    static TimerConfigBlock timerConfigBlock = {
            .control = {
                    .enable = 1,
                    .reset = 1,
            },
            .freqSec = 1,
            .tickCounter = 0,
    };

    AddPeripheral(CPUIntFlag::INT0, CPUKnownIntIds::kTimer0, Timer::Create(&timerConfigBlock));
}

void VirtualCPU::Begin(void *ptrRam, size_t sizeOfRam) {
    CPUBase::Begin(ptrRam, sizeOfRam);

    // Create the timers
    AddPeripheral(CPUIntFlag::INT0, CPUKnownIntIds::kTimer0, Timer::Create(&systemBlock->timer0));
}


void VirtualCPU::Reset() {
    CPUBase::Reset();
}

// Use this for debugging and similar..
bool VirtualCPU::Step() {

    // FIXME: Need to check if ISR's are enabled


    // 1) update peripherals
    UpdatePeripherals();

    // 2) Invoke any Interrupt as a result..
    //    Note: Can't invoke interrupt if already inside one..
    InvokeISRHandlers();

    lastDecodedInstruction.cpuRegistersBefore = registers;
    lastDecodedInstruction.instrDecoder = {};
    if (GetActiveISRControlBlock() != nullptr) {
        lastDecodedInstruction.isrStateBefore = GetActiveISRControlBlock()->isrState;
    }

    // if CPU is halted and we idle/waiting for ISR, don't decode and skip..
    if ((registers.statusReg.flags.halt == 1) && (GetActiveISRControlBlock() != nullptr)) {
        // FIXME: A lot of things are 'wrong' here - esp. when we dump 'lastDecodedInstr'..
        return true;
    }

    auto &instructionSet = GetInstructionSet();
    auto &instructionDecoder = instructionSet.GetDecoder();

    //InstructionDecoderBase::Ref instrDecoder = InstructionDecoder::Create();
    instructionDecoder.Decode(*this);

    auto &instrImpl = instructionSet.GetImplementation();
    if (!instrImpl.ExecuteInstruction(*this, instructionDecoder)) {
        return false;
    }

    UpdateMMU();
    if (GetActiveISRControlBlock() != nullptr) {
        lastDecodedInstruction.isrStateAfter = GetActiveISRControlBlock()->isrState;
    }
    lastDecodedInstruction.cpuRegistersAfter = registers;
    // FIXME: Understand directly why I need this - I think it is for 'ToString' of the last decoded instr.
    lastDecodedInstruction.instrDecoder = dynamic_cast<InstructionSetV1Decoder&>(instructionDecoder);
    return true;
}


